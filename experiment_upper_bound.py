from typing import Union, List
import pandas as pd
from matplotlib import rc
import matplotlib.pyplot as plt
import numpy as np

import fire

from experiment.runner import run_experiment


def generate_plots(dataframe: pd.DataFrame, path: str):
    """Generates figures of functional residuals based on dataframe generated by runner.py.

    Args:
        dataframe (pd.DataFrame): Dataframe containing functional residual data resulting from runner.py.
        path (str, optional): Full save path.
    """

    rc('font', **{'family': 'serif', 'serif': ['Computer Modern']})
    rc('text', usetex=True)
    fsize = 15
    fsize_theory = 25
    line_offset = 0.5
    line_thickness = 3
    
    groupby_keys = ['min_eig', 'max_eig', 'regularization_strength', 'power', 'dimension', 'solution_norm', 'eigendist', 'pidist']
    for key, group in dataframe.groupby(groupby_keys, dropna=False):

        # Unpack key
        (mu, L, s, p, d, r, eigendist, pidist) = key

        # Setup axis with log-log scale
        fig, ax = plt.subplots()
        ax.set_xscale('symlog')
        ax.set_yscale('log')
        ax.minorticks_off()

        # Plot individual runs (grouped by seed)
        # This only happens with randomly generated problem instances
        n_seeds = group.seed.nunique()
        if n_seeds > 1:
            for i, (_, seed_group) in enumerate(group.groupby('seed')):
                fres_gd = np.array(seed_group[(seed_group['method'] == 'GD')]['functional_residual'])
                ax.plot(seed_group[(seed_group['method'] == 'GD')]['iteration'], fres_gd, alpha=0.15, 
                        color='red', linewidth=2)
            
        # Plot per-iteration functional residual
        fres = group.groupby('iteration')['functional_residual'].max()
        wcx = np.array(fres.index)
        wcy = np.array(fres)
        label_gd = 'Gradient method'
        ax.plot(wcx, wcy, color='red', label=label_gd, linewidth=line_thickness)

        # Plot horizontal line of fast convergence
        F0 = wcy[0]
        M_star = L + s * (p - 1) * 2**(p-2) * r**(p-2)
        sigma = s * 2.0**(2-p)
        c2 = 1 / (2 * M_star) * (p / (p-1))**(2*(p-1)/p) * sigma**(2/p)

        # If power is an integer, set it to the string of that integer
        power = p / (p - 2)
        if power.is_integer():
            power_str = str(int(power))
        else:
            power_str = r'\frac{p}{p-2}'
        
        # Plot theoretical upper bound
        nct = F0 * (1 / (F0**((p-2)/p) * c2 * (p-2) / p * wcx + 1))**((p)/(p-2))
        ax.plot(wcx, nct, color='blue', linestyle='--', linewidth=line_thickness)

        iterations = np.arange(1, wcx.max()+1)
        visual_middle = int(np.sqrt(iterations[0] * iterations[-1]))
        dx = np.diff(iterations)[visual_middle]
        unif_dy = np.diff(nct)[visual_middle]
        unif_angle = np.rad2deg(np.arctan2(unif_dy, dx)) * 1.4
        ax.text(iterations[visual_middle], 
                nct[visual_middle], 
                '\n' + r'$\mathcal{O}(k^{-' + power_str + r'})$', 
                linespacing = line_offset,
                transform_rotates_text=True,
                rotation=unif_angle,
                rotation_mode='anchor',
                color='blue', 
                fontweight='bold', 
                fontsize=fsize_theory,
                horizontalalignment='center', 
                verticalalignment='top')

        # Hide bounding box
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        ax.spines['left'].set_visible(False)

        ax.set_xlabel(r'Number of iterations $k$', fontsize=fsize)
        ax.set_ylabel(r'$f(x_k) - f(x_\star)$', fontsize=fsize)

        # Add title
        title = r'Gradient method with $\eta_k = \min\Big\{\frac{1}{M_\star}, \bigl[\frac{p}{s2^{p-2} \|\nabla f(x_k)\|^{p-2}}\bigr]^{\frac{1}{p-1}}\Big\}$'
        ax.set_title(title, fontsize=fsize)

        plt.grid()

        fig.savefig(path)
        plt.close(fig)


def main(repetitions: int = 1,
         min_eig: Union[float, List[float]] = 0,
         max_eig: Union[float, List[float]] = 1,
         regularization: Union[float, List[float]] = 0.1,
         power: Union[int, List[int]] = 3,
         dimensions: int = 1000,
         solution_dist: Union[float, str, List[float]] = 1,
         problem_type: str = 'random',
         solvers: Union[str, List[str]] = 'GD'):
    """Main function for running experiments and generating plots.

    Default arguments correspond to Figure 1 in the paper.
    
    Args:
        repetitions (int, optional): Number of times to repeat experiment. Defaults to 1.
        min_eig (Union[float, List[float]], optional): Smallest eigenvalue of A. Defaults to 0.
        max_eig (Union[float, List[float]], optional): Largest eigenvalue of A. Defaults to 0.1.
        regularization (Union[float, List[float]], optional): Regularization strength (s). Defaults to 1.
        power (Union[int, List[int]], optional): Power of the regularizer. Defaults to 3.
        dimensions (int, optional): Dimension of problem instance. Defaults to 1000.
        solution_dist (Union[float, str, List[float]], optional): Norm of the solution vector. Defaults to 1.
        problem_type (str, optional): Problem type (see problem_generator_factory in regularized_quadratic.py).
        Defaults to 'random'.
        solvers (Union[str, List[str]], optional): Solvers to use (see run_experiment from runner.py). Defaults to 'GD'.
    """

    N = int(dimensions / 2) - 1
    df = run_experiment(
        repetitions = repetitions, 
        min_eig = min_eig, 
        max_eig = max_eig, 
        regularization = regularization, 
        power = power, 
        dimensions = dimensions, 
        solution_dist = solution_dist, 
        iterations = N,
        problem_type = problem_type, 
        solvers = solvers,
    )

    # Save plots
    generate_plots(df, 'figures/experiment_upper_bound.pdf')


if __name__ == '__main__':
    fire.Fire(main)

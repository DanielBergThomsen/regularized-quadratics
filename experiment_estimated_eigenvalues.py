from typing import Union, List
import pandas as pd
from matplotlib import rc
import matplotlib.pyplot as plt
import numpy as np

import fire

from experiment.runner import run_experiment
from experiment.regularized_quadratic import chebyshev_extrema


def eigenval_plots(eigenvals: dict, path: str = 'figures/eigenvals_beta.pdf'):
    """Generates figures of histograms based on dataframe generated by runner.py. 
    
    This function assumes that the dataframe contains data from the beta distribution.

    Args:
        eigenvals (dict): Dictionary containing eigenvalues for each experiment.
        path (str, optional): Full save path. Defaults to 'figures/eigenvals_beta.pdf'.
    """
    rc('font', **{'family': 'serif', 'serif': ['Computer Modern']})
    rc('text', usetex=True)
    bins = 40
    fsize = 20
    for key, eigenvals in eigenvals.items():
        (mu, L, s, p, d, x_dist, eigendist, pidist) = key

        # Skip if not beta distribution
        if not eigendist.startswith('beta_'):
            continue

        fig, ax = plt.subplots()

        # Histogram for chebyshev extrema
        sr = s * x_dist**(p - 2) if x_dist != 'worst_case' else s * (L / (s * d**2))**(p - 2)
        chebyshev = chebyshev_extrema(L + sr, mu + sr, d)
        ax.hist(chebyshev, bins=bins, color='blue', alpha=1.0, label='$\\lambda$ generated adversarially')

        # Histograms for beta-distributed eigenvalues
        ax.hist(eigenvals, bins=bins, color='red', alpha=0.75, label=r'$\lambda_i \sim \beta(0.48, 0.48)$')

        ax.legend(fontsize=fsize)
        fig.savefig(path)
        plt.close(fig)

def generate_plots(dataframe: pd.DataFrame, path: str):
    """Generates figures of functional residual based on dataframe generated by runner.py.

    Args:
        dataframe (pd.DataFrame): Dataframe containing functional residual data resulting from runner.py.
        path (str, optional): Full save path.
    """

    rc('font', **{'family': 'serif', 'serif': ['Computer Modern']})
    rc('text', usetex=True)
    fsize = 20
    line_thickness = 3
    
    groupby_keys = ['min_eig', 'max_eig', 'regularization_strength', 'power', 'dimension', 'solution_norm', 'pidist']
    for key, group in dataframe.groupby(groupby_keys, dropna=False):

        # Setup axis with log-log scale
        fig, ax = plt.subplots()
        ax.set_xscale('symlog')
        ax.set_yscale('log')
        ax.minorticks_off()
            
        # Plot per-iteration functional residual for Krylov subspace method
        worst_case_kr = group[group['eigendist'] == 'adversarial']
        wcx = np.array(worst_case_kr.iteration)
        wcy = np.array(worst_case_kr.functional_residual)
        ax.plot(wcx, wcy, color='blue', label='$\\lambda$ generated adversarially', linewidth=line_thickness)

        # Plot per-iteration functional residual for GD
        worst_case_gd = group[group['eigendist'] == 'beta_0.48_0.48']
        wcx = np.array(worst_case_gd.iteration)
        wcy = np.array(worst_case_gd.functional_residual)
        ax.plot(wcx, wcy, color='red', label='$\\lambda_i \\sim \\beta(0.48, 0.48)$', linewidth=line_thickness)

        # Hide bounding box
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        ax.spines['left'].set_visible(False)

        ax.legend(loc='lower left', fontsize=fsize)

        ax.set_xlabel(r'Number of iterations $k$', fontsize=fsize)
        ax.set_ylabel(r'$f(x_k) - f(x_\star)$', fontsize=fsize)

        plt.grid()

        fig.savefig(path)
        plt.close(fig)


def main(repetitions: int = 1,
         min_eig: Union[float, List[float]] = 0,
         max_eig: Union[float, List[float]] = 1000,
         regularization: Union[float, List[float]] = 1,
         power: Union[int, List[int]] = 3,
         dimensions: int = 100,
         solution_dist: Union[float, str, List[float]] = 'worst_case',
         problem_type: str = 'adversarial',
         problem_eigendist: Union[str, List[str]] = ['adversarial', 'beta_0.48_0.48'],
         problem_pidist: Union[str, List[str]] = 'uniform',
         solvers: Union[str, List[str]] = ['krylov_method'],
         figure_path: str = 'figures/eigenvals_beta'):
    """Main function for running experiments and generating plots.

    Default arguments correspond to Figure 6 (a) and (b) in the paper.

    Args:
        repetitions (int, optional): Number of times to repeat experiment. Default to 1.
        (only useful when some randomness involved). Defaults to 1.
        min_eig (Union[float, List[float]], optional): Smallest eigenvalue of A. Defaults to 0.
        max_eig (Union[float, List[float]], optional): Largest eigenvalue of A. Defaults to 1000.
        regularization (Union[float, List[float]], optional): Regularization strength (s). Defaults to 1.
        power (Union[int, List[int]], optional): Power of the regularizer. Defaults to 3.
        dimensions (int, optional): Dimension of problem instance. Defaults to 100.
        solution_dist (Union[float, str, List[float]], optional): Norm of the solution vector. Defaults to 'worst_case'.
        problem_type (str, optional): Problem type (cf. problem_generator_factory in regularized_quadratic.py).
        Defaults to 'adversarial'.
        problem_eigendist (Union[str, List[str]], optional): Distribution of eigenvalues. Defaults to ['adversarial', 'beta_0.48_0.48'].
        problem_pidist (Union[str, List[str]], optional): Distribution of pi. Defaults to 'uniform'.
        solvers (Union[str, List[str]], optional): Solvers to use (cf. run_experiment from runner.py). Defaults to ['krylov_method'].
        figure_path (str): Path to save figure. Defaults to 'figures/eigenvals_beta.pdf'.
    """

    # Get data from running experiment
    N = int(dimensions / 2) - 1
    df, eigenvals = run_experiment(
        repetitions = repetitions, 
        min_eig = min_eig, 
        max_eig = max_eig, 
        regularization = regularization, 
        power = power, 
        dimensions = dimensions, 
        solution_dist = solution_dist, 
        iterations = N,
        problem_type = problem_type, 
        solvers = solvers,
        problem_eigendist = problem_eigendist,
        problem_pidist = problem_pidist,
        save_eigenvalues=True
    )

    generate_plots(df, figure_path + '_experiment.pdf')
    eigenval_plots(eigenvals, figure_path + '_histogram.pdf')


if __name__ == '__main__':
    fire.Fire(main)

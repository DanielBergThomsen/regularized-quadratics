from typing import Union, List
import pandas as pd
from matplotlib import rc
import matplotlib.pyplot as plt
import numpy as np
import itertools

import fire

from experiment.runner import run_experiment


def generate_plots(dataframe: pd.DataFrame, path: str):
    """Generates figures of functional residual based on dataframe generated by runner.py.

    This function also handles the case where different seeds are used for random problem instances.

    Args:
        dataframe (pd.DataFrame): Dataframe containing functional residual data resulting from runner.py.
        path (str, optional): Full save path. Defaults to 'figures/eigenvals_beta_experiment.pdf
    """

    rc('font', **{'family': 'serif', 'serif': ['Computer Modern']})
    rc('text', usetex=True)
    fsize = 15
    line_thickness = 2
    
    Ls = np.sort(dataframe['max_eig'].unique())
    ss = np.sort(dataframe['regularization_strength'].unique())
    fig, axs = plt.subplots(len(ss), len(Ls))
    for (i, L), (j, s) in itertools.product(enumerate(Ls), enumerate(ss)):

        # Choose axis
        ax = axs[i, j]

        # Filter dataframe
        group = dataframe[(dataframe['max_eig'] == L) & (dataframe['regularization_strength'] == s)]

        # Setup axis with log-log scale
        ax.set_xscale('symlog')
        ax.set_yscale('log')
        ax.minorticks_off()
            
        # Plot individual runs (grouped by seed)
        # This only happens with randomly generated problem instances
        n_seeds = group.seed.nunique()
        if n_seeds > 1:
            for i, (_, seed_group) in enumerate(group.groupby('seed')):
                fres_kr = np.array(seed_group[seed_group['method'] == 'krylov_method']['functional_residual'])
                fres_gd = np.array(seed_group[~(seed_group['method'] == 'krylov_method')]['functional_residual'])
                ax.plot(seed_group[seed_group['method'] == 'krylov_method']['iteration'], fres_kr, alpha=0.15, color='blue', linewidth=1)  # label='Individual runs' if i == 0 else ""
                ax.plot(seed_group[~(seed_group['method'] == 'krylov_method')]['iteration'], fres_gd, alpha=0.15, color='red', linewidth=1)

        # Plot per-iteration worst-case for Krylov subspace method
        worst_case_kr = group[group['method'] == 'krylov_method'].groupby('iteration')['functional_residual'].min()
        wcx = np.array(worst_case_kr.index)
        wcy = np.array(worst_case_kr)
        label_kr = 'Krylov subspace solver'
        ax.plot(wcx, wcy, color='blue', label=label_kr, linewidth=line_thickness)

        # Plot per-iteration worst-case for GD
        worst_case_gd = group[~(group['method'] == 'krylov_method')].groupby('iteration')['functional_residual'].min()
        wcx = np.array(worst_case_gd.index)
        wcy = np.array(worst_case_gd)
        label_gd = 'Gradient method'
        ax.plot(wcx, wcy, color='red', label=label_gd, linewidth=line_thickness)

        # Display L and s in the upper left corner in a gray box
        textstr = f'$L = {L}$\n$s = {s}$'
        props = dict(boxstyle='round', facecolor=(0.93, 0.93, 0.93), alpha=1.0, linewidth=0.5, edgecolor='gray')
        ax.text(0.10, 0.34, textstr, transform=ax.transAxes, fontsize=10, verticalalignment='top', bbox=props)

        # Hide bounding box
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        ax.spines['left'].set_visible(False)

        # Put grid lines
        ax.grid()

    fig.supxlabel(r'Number of iterations $k$', fontsize=fsize)
    fig.supylabel(r'$f(x_k) - f(x_\star)$', fontsize=fsize)

    fig.savefig(path)
    plt.close(fig)


def main(repetitions: int = 100,
         min_eig: Union[float, List[float]] = 0,
         max_eig: Union[float, List[float]] = [10, 100, 1000],
         regularization: Union[float, List[float]] = [0.1, 1, 10],
         power: Union[int, List[int]] = 3,
         dimensions: int = 100,
         solution_dist: Union[float, str, List[float]] = 1,
         problem_type: str = 'random',
         solvers: Union[str, List[str]] = ['krylov_method', 'GD']):
    """Main function for running experiments and generating plots.

    Default arguments correspond to Figure 7 in the paper.
    
    Args:
        repetitions (int, optional): Number of times to repeat experiment. Defaults to 1.
        min_eig (Union[float, List[float]], optional): Smallest eigenvalue of A. Defaults to 0.
        max_eig (Union[float, List[float]], optional): Largest eigenvalue of A. Defaults to 1000.
        regularization (Union[float, List[float]], optional): Regularization strength (s). Defaults to 1.
        power (Union[int, List[int]], optional): Power of the regularizer. Defaults to 3.
        dimensions (int, optional): Dimension of problem instance. Defaults to 100.
        solution_dist (Union[float, str, List[float]], optional): Norm of the solution vector. Defaults to 'worst_case'.
        problem_type (str, optional): Problem type (cf. problem_generator_factory in regularized_quadratic.py).
        Defaults to ['adversarial', 'random'].
        solvers (Union[str, List[str]], optional): Solvers to use (cf. run_experiment from runner.py). Defaults to ['krylov_method, GD'].
    """

    N = int(dimensions / 2) - 1
    df = run_experiment(
        repetitions = repetitions, 
        min_eig = min_eig, 
        max_eig = max_eig, 
        regularization = regularization, 
        power = power, 
        dimensions = dimensions, 
        solution_dist = solution_dist, 
        iterations = N,
        problem_type = problem_type, 
        solvers = solvers,
    )

    # Save random and adversarial runs separately
    generate_plots(df, 'figures/functional_residual_grid.pdf')


if __name__ == '__main__':
    fire.Fire(main)

from typing import Union, List
import pandas as pd
from matplotlib import rc
import matplotlib.pyplot as plt
import numpy as np

import fire

from experiment.runner import run_experiment


def generate_plots(dataframe: pd.DataFrame, path: str):
    """Generates figures of functional residual based on dataframe generated by runner.py.

    This function also handles the case where different seeds are used for random problem instances.

    Args:
        dataframe (pd.DataFrame): Dataframe containing functional residual data resulting from runner.py.
        path (str, optional): Full save path. Defaults to 'figures/eigenvals_beta_experiment.pdf
    """

    rc('font', **{'family': 'serif', 'serif': ['Computer Modern']})
    rc('text', usetex=True)
    fsize = 20
    line_thickness = 3
    
    groupby_keys = ['min_eig', 'max_eig', 'regularization_strength', 'power', 'dimension', 'solution_norm', 'eigendist', 'pidist']
    for key, group in dataframe.groupby(groupby_keys, dropna=False):

        # Unpack key
        (mu, L, s, p, d, x_dist, eigendist, pidist) = key

        # Setup axis with log-log scale
        fig, ax = plt.subplots()
        ax.set_xscale('symlog')
        ax.set_yscale('log')
        ax.minorticks_off()
            
        # Plot individual runs (grouped by seed)
        # This only happens with randomly generated problem instances
        n_seeds = group.seed.nunique()
        if n_seeds > 1:
            for i, (_, seed_group) in enumerate(group.groupby('seed')):
                fres_kr = np.array(seed_group[seed_group['method'] == 'krylov_method']['functional_residual'])
                fres_gd = np.array(seed_group[~(seed_group['method'] == 'krylov_method')]['functional_residual'])
                ax.plot(seed_group[seed_group['method'] == 'krylov_method']['iteration'], fres_kr, alpha=0.15, color='blue', linewidth=1)  # label='Individual runs' if i == 0 else ""
                ax.plot(seed_group[~(seed_group['method'] == 'krylov_method')]['iteration'], fres_gd, alpha=0.15, color='red', linewidth=1)

        # Plot per-iteration worst-case for Krylov subspace method
        worst_case_kr = group[group['method'] == 'krylov_method'].groupby('iteration')['functional_residual'].min()
        wcx = np.array(worst_case_kr.index)
        wcy = np.array(worst_case_kr)
        label_kr = 'Krylov subspace solver'
        ax.plot(wcx, wcy, color='blue', label=label_kr, linewidth=line_thickness)

        # Plot per-iteration worst-case for GD
        worst_case_gd = group[~(group['method'] == 'krylov_method')].groupby('iteration')['functional_residual'].min()
        wcx = np.array(worst_case_gd.index)
        wcy = np.array(worst_case_gd)
        label_gd = 'Gradient method'
        ax.plot(wcx, wcy, color='red', label=label_gd, linewidth=line_thickness)

        # Hide bounding box
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        ax.spines['left'].set_visible(False)

        ax.legend(loc='lower left', fontsize=fsize)

        ax.set_xlabel(r'Number of iterations $k$', fontsize=fsize)
        ax.set_ylabel(r'$f(x_k) - f(x_\star)$', fontsize=fsize)

        plt.grid()

        fig.savefig(path)
        plt.close(fig)


def main(repetitions: int = 100,
         min_eig: Union[float, List[float]] = 0,
         max_eig: Union[float, List[float]] = 1000,
         regularization: Union[float, List[float]] = 1,
         power: Union[int, List[int]] = 3,
         dimensions: int = 100,
         solution_dist: Union[float, str, List[float]] = 1,
         problem_type: str = ['adversarial', 'random'],
         problem_eigendist: Union[str, List[str]] = 'adversarial',
         problem_pidist: Union[str, List[str]] = 'heuristic',
         solvers: Union[str, List[str]] = ['krylov_method', 'GD']):
    """Main function for running experiments and generating plots.

    Default arguments correspond to Figure 3 (a) and (b) in the paper.
    
    Args:
        repetitions (int, optional): Number of times to repeat experiment. Defaults to 1.
        min_eig (Union[float, List[float]], optional): Smallest eigenvalue of A. Defaults to 0.
        max_eig (Union[float, List[float]], optional): Largest eigenvalue of A. Defaults to 1000.
        regularization (Union[float, List[float]], optional): Regularization strength (s). Defaults to 1.
        power (Union[int, List[int]], optional): Power of the regularizer. Defaults to 3.
        dimensions (int, optional): Dimension of problem instance. Defaults to 100.
        solution_dist (Union[float, str, List[float]], optional): Norm of the solution vector. Defaults to 'worst_case'.
        problem_type (str, optional): Problem type (cf. problem_generator_factory in regularized_quadratic.py).
        Defaults to ['adversarial', 'random'].
        problem_eigendist (Union[str, List[str]], optional): Distribution of eigenvalues. Defaults to 'adversarial'.
        problem_pidist (Union[str, List[str]], optional): Distribution of pi. Defaults to 'heuristic'.
        solvers (Union[str, List[str]], optional): Solvers to use (cf. run_experiment from runner.py). Defaults to ['krylov_method, GD'].
    """

    N = int(dimensions / 2) - 1
    df = run_experiment(
        repetitions = repetitions, 
        min_eig = min_eig, 
        max_eig = max_eig, 
        regularization = regularization, 
        power = power, 
        dimensions = dimensions, 
        solution_dist = solution_dist, 
        iterations = N,
        problem_type = problem_type, 
        solvers = solvers,
        problem_eigendist = problem_eigendist,
        problem_pidist = problem_pidist
    )

    # Save random and adversarial runs separately
    df_adv = df[df['problem_type'] == 'adversarial']
    adv_save_path = 'figures/functional_residual_adversarial.pdf' 
    generate_plots(df_adv, adv_save_path)
    
    df_rnd = df[df['problem_type'] == 'random']
    rnd_save_path = 'figures/functional_residual_random.pdf'
    generate_plots(df_rnd, rnd_save_path)


if __name__ == '__main__':
    fire.Fire(main)

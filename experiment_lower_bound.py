from typing import Union, List

import pandas as pd
from matplotlib import rc
import matplotlib.pyplot as plt
import numpy as np

import fire

from experiment.runner import run_experiment


def generate_plots(dataframe: pd.DataFrame, path: str):
    """Generates figures of functional residual based on dataframe generated by runner.py.

    Args:
        dataframe (pd.DataFrame): Dataframe containing functional residual data resulting from runner.py.
        path (str): Full save path.
    """

    rc('font', **{'family': 'serif', 'serif': ['Computer Modern']})
    rc('text', usetex=True)
    fsize = 15
    fsize_theory = 25
    line_offset = 0.5  # This may not actually do anything
    line_thickness = 2
    trend_thickness = 3
    
    # Sets the label for the power of the regularizer (if there are multiple)
    set_p_label = len(dataframe.power.unique()) > 1
    groupby_keys = ['min_eig', 'max_eig', 'regularization_strength', 'power', 'dimension']
    for key, group in dataframe.groupby(groupby_keys, dropna=False):

        # Unpack key
        (mu, L, s, p, d) = key

        # Generate plot
        fig, ax = plt.subplots()
        ax.set_xscale('log')
        ax.set_yscale('log')
        ax.minorticks_off()
            
        # Get pointwise maximum for each method
        pointwise_maximum_krylov = group[group['method'] == 'krylov_method'].groupby(['max_iterations']).min().groupby('max_iterations')['functional_residual'].max()
        pointwise_maximum_gd = group[~(group['method'] == 'krylov_method')].groupby(['max_iterations']).min().groupby(['max_iterations'])['functional_residual'].max()

        # Plot for Krylov subspace solver
        wcx = np.array(pointwise_maximum_krylov.index)
        wcy = np.array(pointwise_maximum_krylov)
        ax.plot(wcx, wcy, color='black', linestyle='-', marker='*', label='Krylov subspace solver', linewidth=line_thickness)

        # Plot for gradient descent
        wcx = np.array(pointwise_maximum_gd.index)
        wcy = np.array(pointwise_maximum_gd)
        ax.plot(wcx, wcy, color='red', linestyle='-', marker='o', label='Gradient method', linewidth=line_thickness)

        # Setup for plotting theoretical lower bound
        iterations = np.arange(1, wcx.max()+1)
        visual_middle = int(np.sqrt(iterations[0] * iterations[-1]))
        dx = np.diff(iterations)[visual_middle]

        # If power is an integer, set it to the string of that integer
        power = 2 * p / (p - 2)
        if power.is_integer():
            power_str = str(int(power))
        else:
            power_str = r'\frac{2p}{p-2}'
        
        # This is a heuristic inspired by the constants in the proof of the lower bound
        const_theory = (2*(p-2))*(1e-4)

        # Plot our prediction
        unif_cvx = const_theory * (L / (s**(2 / p) * np.power([k for k in iterations], 2)))**(p / (p - 2))
        ax.plot(iterations, unif_cvx, color='blue', linestyle='--', linewidth=trend_thickness)
        unif_dy = np.diff(unif_cvx)[visual_middle]
        unif_angle = np.rad2deg(np.arctan2(unif_dy, dx)) * 1.4
        ax.text(iterations[visual_middle], 
                unif_cvx[visual_middle], 
                '\n $\\Omega(N^{-' + power_str + '})$', 
                linespacing = line_offset,
                transform_rotates_text=True,
                rotation=unif_angle,
                rotation_mode='anchor',
                color='blue', 
                fontweight='bold', 
                fontsize=fsize_theory,
                horizontalalignment='center', 
                verticalalignment='top')

        # Textbox to show power of regularizer
        if set_p_label:
            ax.text(0.9, 
                    0.9, 
                    f'$p={p}$', 
                    transform=ax.transAxes, 
                    fontsize=20, 
                    verticalalignment='top', 
                    horizontalalignment='right',
                    bbox = dict(boxstyle='round', facecolor='lightgray', alpha=0.5)
            )

        # Hide bounding box
        ax.spines['top'].set_visible(False)
        ax.spines['right'].set_visible(False)
        ax.spines['left'].set_visible(False)

        ax.legend(loc='upper right', fontsize=fsize)

        ax.set_xlabel(r'Maximum number of iterations $N$', fontsize=fsize)
        ax.set_ylabel(r'Lowest residual for construction', fontsize=fsize)

        plt.grid()

        fig.savefig(path)
        plt.close(fig)


def main(repetitions: int = 1,
         min_eig: Union[float, List[float]] = 0, 
         max_eig: Union[float, List[float]] = 1000, 
         regularization: Union[float, List[float]] = 1, 
         power: Union[int, List[int]] = 3, 
         dimensions: int = 1000, 
         resolution: int = 20,
         solution_dist: Union[float, str, List[float]] = 'worst_case',
         problem_type: str = 'adversarial',
         problem_eigendist: Union[str, List[str]] = 'adversarial',
         problem_pidist: Union[str, List[str]] = 'heuristic',
         solvers: Union[str, List[str]] = ['krylov_method', 'GD'],
         figure_path: str = 'figures/lower_bound_solver_experiment.pdf'):
    """Run experiment and generate plots.

    Default arguments correspond to Figure 4 in the paper.
    
    Args:
        repetitions (int, optional): Number of times to repeat experiment. Defaults to 1.
        min_eig (Union[float, List[float]], optional): Smallest eigenvalue of A. Defaults to 0.
        max_eig (Union[float, List[float]], optional): Largest eigenvalue of A. Defaults to 1000.
        regularization (Union[float, List[float]], optional): Regularization strength (s). Defaults to 1.
        power (Union[int, List[int]], optional): Power of the regularizer. Defaults to 3.
        dimensions (int, optional): Dimension of problem instance. Defaults to 1000.
        resolution (int, optional): Number of different values of N to use. Defaults to 20.
        solution_dist (Union[float, str, List[float]], optional): Norm of the solution. Defaults to 'worst_case'.
        problem_type (str, optional): Type of problem. Defaults to 'adversarial'.
        problem_eigendist (Union[str, List[str]], optional): Distribution of eigenvalues. Defaults to 'adversarial'.
        problem_pidist (Union[str, List[str]], optional): Distribution of pi. Defaults to 'heuristic'.
        solvers (Union[str, List[str]], optional): List of solvers to use. Defaults to ['krylov_method', 'GD'].
        figure_path (str, optional): Path to save figure. Defaults to 'figures/lower_bound_solver_experiment.pdf'.
    """

    # Geometrically spaced N to have roughly equal spacing in log scale for plots
    Ns = np.geomspace(1, int((dimensions-1) / 2), resolution, dtype=int)
    Ns = np.unique(Ns)

    df = run_experiment(
        repetitions = repetitions, 
        min_eig = min_eig, 
        max_eig = max_eig, 
        regularization = regularization, 
        power = power, 
        dimensions = dimensions, 
        iterations = Ns, 
        solution_dist = solution_dist, 
        problem_type = problem_type, 
        problem_eigendist = problem_eigendist,
        problem_pidist = problem_pidist,
        solvers = solvers, 
        save_eigenvalues=False
    )
    generate_plots(df, figure_path)


if __name__ == '__main__':
    fire.Fire(main)
